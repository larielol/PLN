# -*- coding: utf-8 -*-
"""Lab_Regex_Mod_Lucas_Ariel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iKVHL1by0soQusqa_URkuQ94_7LvUT7A
"""

import re

# Texto original do di√°rio
diario = """
[DATA: 2024-11-03 | HORA: 02:17]

Na madrugada, finalizei o pentest no sistema legado da OmegaSec.
Consegui acesso via endpoint `/api/v1/users?token=21a8a8bbd3e1a7ad12b`.
O IP exposto era 10.0.0.142, mas logo percebi que ele redirecionava para 177.134.12.88:8080 via nginx.

Encontrei credenciais antigas armazenadas no HTML:
Email(s): roberta.souza@omegasec.com, roberta_souza123@sec.com
Senha: OmeGa$2021 (rid√≠cula).
Senha alternativa: Rob_souza$2021 (rid√≠cula).
O token da sess√£o era: Bearer 88ac32adbe10abc99122f.

Tamb√©m encontrei um c√≥digo aleat√≥rio. Por√©m √© apenas de uma compra de uma roupa. O c√≥digo √© lojas2024$2025.

Usu√°rio testava o cart√£o 1234 5678 9012 3456 para compras em staging.
Telefone(s) cadastrado(s):
(85) 99876-1234 | 859945-5464 | 85 98988-1479
CPF: 234.567.890-12
Nome completo: Roberta Souza.

OBS: Apaguei tudo do log p√∫blico. Mas o backup do banco estava dispon√≠vel em:
https://db-backup.omegasec.com/export/full.zip?access_token=abc321zzx

Mais tarde, revisei outra inst√¢ncia na AWS com IP 18.223.112.100 e usu√°rio "admin@example.com".
Este email n√£o deveria ser confundido com o link: https://example.com/admin@example.com/login

Por fim, notei que logs internos estavam expondo CPFs embutidos:
`user_cpf_998.877.665-44_data.log`

E pra variar, encontrei outro cart√£o, mas s√≥ salvei os √∫ltimos d√≠gitos: 4321.

Agora vou dormir.
- Shadow_0x
"""

# üß™ Tarefa 1: Crie uma fun√ß√£o para mascarar todos os CPFs (inclusive embutidos)
def mascarar_cpf(texto):
    return re.sub(r'\d{3}\.\d{3}\.\d{3}-\d{2}', '<CPF>', texto)

# üß™ Tarefa 2: Crie uma fun√ß√£o para mascarar e-mails (deixe apenas o dom√≠nio vis√≠vel)
def mascarar_email(texto):
    return re.sub(r'(?<=\b)[\w\.-]+(?=@[\w\.-]+\.\w+)', '<EMAIL>', texto)

# üß™ Tarefa 3: Crie uma fun√ß√£o para mascarar n√∫meros de telefone
def mascarar_telefone(texto):
    return re.sub(r'\(?\d{2,3}\)?[\s-]?\d{4,5}[\s-]?\d{4}', '<TELEFONE>', texto)

# üß™ Tarefa 4: Crie uma fun√ß√£o para ocultar IPs (ex: 192.168.0.1 --> <IP OCULTO>)
def ocultar_ips(texto):
    return re.sub(r'\b(?:\d{1,3}.){3}\d{1,3}\b(:\d+)?', '<IP OCULTO>', texto)

# üß™ Tarefa 5: Crie uma fun√ß√£o para remover tokens (Bearer e em URLs e querystrings)
def remover_tokens(texto):
    texto = re.sub(r'(token=|access_token=)[\w-]+', r'\1<TOKEN>', texto)
    texto = re.sub(r'Bearer\s+[\w-]+', 'Bearer <TOKEN>', texto)
    return texto

# üß™ Tarefa 6: Crie uma fun√ß√£o para anonimizar nomes pr√≥prios (ex: "Roberta Souza" --> [REDACTED])
def anonimizar_nomes(texto):
    return re.sub(r'\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+\b', '[REDACTED]', texto)

# üß™ Tarefa 7: Crie uma fun√ß√£o para remover links inteiros por [LINK REMOVIDO]
def remover_links(texto):
    return re.sub(r'https?://[^\s]+', '[LINK REMOVIDO]', texto)

# ÔøΩ Tarefa 8: Crie uma fun√ß√£o para mascarar cart√µes de cr√©dito (mostrar apenas os 4 √∫ltimos)
def mascarar_cartao(texto):
    return re.sub(r'\b\d{4}\s?\d{4}\s?\d{4}\s?\d{4}\b', '**** **** **** 3456', texto)

# üß™ Tarefa 9: Crie uma fun√ß√£o para mascarar as senhas
def mascarar_senha(texto):
    return re.sub(r'(Senha(?: alternativa)?:\s*)[^\s]+', r'\1<SENHA>', texto)

def processar_diario(texto):
    """Aplica todas as fun√ß√µes de mascaramento ao di√°rio"""
    # A ordem de aplica√ß√£o √© importante!
    texto = mascarar_cpf(texto)
    texto = mascarar_email(texto)
    texto = mascarar_telefone(texto)
    texto = ocultar_ips(texto)
    texto = remover_tokens(texto)
    texto = anonimizar_nomes(texto)
    texto = remover_links(texto)
    texto = mascarar_cartao(texto)
    texto = mascarar_senha(texto)
    return texto

def main():
    """Fun√ß√£o principal para execu√ß√£o do script"""
    print("=== Di√°rio Original ===")
    print(diario)

    print("\n=== Di√°rio Processado ===")
    texto_processado = processar_diario(diario)
    print(texto_processado)

if __name__ == "__main__":
    main()